name: Build and Release

on:
  push:
    tags:
      - 'v*'  # Запускается при создании тега вида v1.0.0
  workflow_dispatch:  # Позволяет запускать вручную

jobs:
  build-linux:
    name: Build Linux
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Qt
        uses: jurplel/install-qt-action@v3
        with:
          version: '6.8.0'
          arch: 'linux_gcc_64'
          aqtversion: '>=3.3.0'
          cache: 'true'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            cmake \
            ninja-build \
            libfluidsynth-dev \
            git \
            libgl1-mesa-dev \
            libxkbcommon-x11-0 \
            libxcb-xinerama0

      - name: Setup vcpkg
        uses: actions/checkout@v4
        with:
          repository: microsoft/vcpkg
          path: vcpkg

      - name: Install vcpkg dependencies
        run: |
          cd vcpkg
          ./bootstrap-vcpkg.sh
          ./vcpkg install fluidsynth:x64-linux

      - name: Configure CMake
        env:
          VCPKG_ROOT: ${{ github.workspace }}/vcpkg
          Qt6_DIR: ${{ env.Qt6_DIR }}
        run: |
          cmake -B build -S . \
            -DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_PREFIX_PATH="${{ env.Qt6_DIR }}" \
            -G Ninja

      - name: Build
        run: cmake --build build --config Release

      - name: Install to staging directory
        run: |
          mkdir -p staging
          cmake --install build --prefix ${{ github.workspace }}/staging

      - name: Deploy Qt dependencies
        env:
          Qt6_DIR: ${{ env.Qt6_DIR }}
        run: |
          STAGING_DIR="${{ github.workspace }}/staging"
          mkdir -p "$STAGING_DIR/bin" "$STAGING_DIR/qml" "$STAGING_DIR/plugins"
          
          QT_DIR="${{ env.Qt6_DIR }}"
          echo "Qt6 directory: $QT_DIR"
          echo "Staging directory: $STAGING_DIR"
          
          # Используем linuxdeployqt или копируем вручную
          # Копируем необходимые Qt библиотеки из установленного Qt
          if [ -d "$QT_DIR/lib" ]; then
            # Копируем Qt библиотеки
            ldd "$STAGING_DIR/bin/pimino" | grep "libQt6" | awk '{print $3}' | while read lib; do
              if [ -f "$lib" ]; then
                cp "$lib" "$STAGING_DIR/bin/"
              fi
            done
            
            # Если библиотеки не найдены через ldd, копируем из Qt директории
            if [ ! -f "$STAGING_DIR/bin/libQt6Core.so" ] && [ -f "$QT_DIR/lib/libQt6Core.so" ]; then
              cp "$QT_DIR/lib"/libQt6*.so* "$STAGING_DIR/bin/" 2>/dev/null || true
            fi
          fi
          
          # Копируем QML модули из установленного Qt
          if [ -d "$QT_DIR/qml" ]; then
            cp -r "$QT_DIR/qml"/* "$STAGING_DIR/qml/" 2>/dev/null || true
          fi
          
          # Копируем плагины Qt
          if [ -d "$QT_DIR/plugins" ]; then
            cp -r "$QT_DIR/plugins"/* "$STAGING_DIR/plugins/" 2>/dev/null || true
          fi
          
          # Также проверяем системные пути на случай если что-то пропустили
          QML_PATHS="/usr/lib/x86_64-linux-gnu/qt6/qml /usr/lib/qt6/qml"
          for qml_path in $QML_PATHS; do
            if [ -d "$qml_path" ] && [ ! -d "$STAGING_DIR/qml/QtQuick" ]; then
              cp -r "$qml_path"/* "$STAGING_DIR/qml/" 2>/dev/null || true
            fi
          done
          
          # Копируем зависимости Qt библиотек
          for lib in "$STAGING_DIR/bin"/libQt6*.so*; do
            if [ -f "$lib" ]; then
              ldd "$lib" 2>/dev/null | grep -v "libQt6" | awk '{print $3}' | while read dep; do
                if [ -f "$dep" ] && [[ "$dep" == *"lib"* ]] && [[ ! "$dep" == *"libc"* ]] && [[ ! "$dep" == *"libpthread"* ]]; then
                  cp "$dep" "$STAGING_DIR/bin/" 2>/dev/null || true
                fi
              done
            fi
          done

      - name: Create source archive
        run: |
          git archive --format=tar.gz --prefix=pimino-${{ github.ref_name }}-src/ -o pimino-${{ github.ref_name }}-src.tar.gz HEAD

      - name: Create Linux archive
        run: |
          cd ${{ github.workspace }}/staging
          tar -czf ${{ github.workspace }}/pimino-${{ github.ref_name }}-linux-x64.tar.gz *
          cd ${{ github.workspace }}
          zip -r pimino-${{ github.ref_name }}-linux-x64.zip staging/*

      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-release
          path: |
            pimino-${{ github.ref_name }}-linux-x64.tar.gz
            pimino-${{ github.ref_name }}-linux-x64.zip
            pimino-${{ github.ref_name }}-src.tar.gz

  build-windows:
    name: Build Windows
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup vcpkg
        uses: actions/checkout@v4
        with:
          repository: microsoft/vcpkg
          path: vcpkg

      - name: Install vcpkg dependencies
        run: |
          cd vcpkg
          .\bootstrap-vcpkg.bat
          .\vcpkg install fluidsynth

      - name: Setup Qt
        uses: jurplel/install-qt-action@v3
        with:
          version: '6.8.0'
          arch: 'win64_msvc2022_64'
          aqtversion: '>=3.3.0'
          cache: 'true'

      - name: Configure CMake
        env:
          VCPKG_ROOT: ${{ github.workspace }}\vcpkg
          Qt6_DIR: ${{ env.Qt6_DIR }}
        run: |
          cmake -B build -S . `
            -DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}\vcpkg\scripts\buildsystems\vcpkg.cmake `
            -DCMAKE_BUILD_TYPE=Release `
            -G "Visual Studio 17 2022" -A x64

      - name: Build
        run: cmake --build build --config Release

      - name: Install to staging directory
        run: |
          mkdir staging
          cmake --install build --prefix ${{ github.workspace }}\staging

      - name: Deploy Qt dependencies
        shell: pwsh
        env:
          Qt6_DIR: ${{ env.Qt6_DIR }}
        run: |
          $qtDir = "$env:Qt6_DIR"
          $qtBin = "$qtDir\bin"
          $stagingBin = "staging\bin"
          $stagingQml = "staging\qml"
          $stagingPlugins = "staging\plugins"
          
          Write-Host "Qt6_DIR: $qtDir"
          Write-Host "Qt Bin: $qtBin"
          
          # Создаем директории
          New-Item -ItemType Directory -Force -Path $stagingBin | Out-Null
          New-Item -ItemType Directory -Force -Path $stagingQml | Out-Null
          New-Item -ItemType Directory -Force -Path $stagingPlugins | Out-Null
          
          # Копируем все необходимые Qt DLL
          $qtDlls = @(
            "Qt6Core.dll", "Qt6Gui.dll", "Qt6Qml.dll", "Qt6Quick.dll",
            "Qt6QuickControls2.dll", "Qt6Svg.dll", "Qt6QmlModels.dll",
            "Qt6QmlWorkerScript.dll", "Qt6Network.dll", "Qt6OpenGL.dll"
          )
          
          foreach ($dll in $qtDlls) {
            $src = "$qtBin\$dll"
            if (Test-Path $src) {
              Copy-Item $src -Destination $stagingBin -Force
              Write-Host "Copied: $dll"
            }
          }
          
          # Копируем QML модули
          $qmlSrc = "$qtDir\qml"
          if (Test-Path $qmlSrc) {
            Copy-Item -Recurse "$qmlSrc\*" -Destination $stagingQml -Force
            Write-Host "Copied QML modules"
          }
          
          # Копируем плагины
          $pluginsSrc = "$qtDir\plugins"
          if (Test-Path $pluginsSrc) {
            Copy-Item -Recurse "$pluginsSrc\*" -Destination $stagingPlugins -Force
            Write-Host "Copied plugins"
          }
          
          # Используем windeployqt если доступен
          $windeployqt = "$qtDir\bin\windeployqt.exe"
          if (Test-Path $windeployqt) {
            Write-Host "Running windeployqt..."
            & $windeployqt --qmldir "$stagingQml" --no-translations "$stagingBin\pimino.exe"
          }

      - name: Create source archive
        run: |
          git archive --format=zip --prefix=pimino-${{ github.ref_name }}-src/ -o pimino-${{ github.ref_name }}-src.zip HEAD

      - name: Create Windows archive
        shell: pwsh
        run: |
          Compress-Archive -Path staging\* -DestinationPath pimino-${{ github.ref_name }}-windows-x64.zip -Force

      - name: Install NSIS
        shell: pwsh
        run: |
          # Устанавливаем NSIS через Chocolatey или напрямую
          Write-Host "Installing NSIS..."
          
          # Проверяем наличие Chocolatey
          if (Get-Command choco -ErrorAction SilentlyContinue) {
            Write-Host "Using Chocolatey to install NSIS"
            choco install nsis -y
          } else {
            Write-Host "Chocolatey not found, installing NSIS manually"
            # Используем прямой URL к установщику NSIS 3.09
            $nsisUrl = "https://github.com/git-for-windows/git/releases/download/v2.43.0.windows.1/PortableGit-2.43.0-64-bit.7z.exe"
            # Правильный URL для NSIS 3.09
            $nsisUrl = "https://sourceforge.net/projects/nsis/files/NSIS%203/3.09/nsis-3.09-setup.exe"
            $nsisInstaller = "$env:TEMP\nsis-3.09-setup.exe"
            
            # Скачиваем установщик с повторными попытками
            Write-Host "Downloading NSIS installer from: $nsisUrl"
            $maxRetries = 3
            $retryCount = 0
            $downloadSuccess = $false
            
            while ($retryCount -lt $maxRetries -and -not $downloadSuccess) {
              try {
                Invoke-WebRequest -Uri $nsisUrl -OutFile $nsisInstaller -UseBasicParsing -TimeoutSec 300
                if (Test-Path $nsisInstaller -and (Get-Item $nsisInstaller).Length -gt 0) {
                  $downloadSuccess = $true
                  Write-Host "NSIS installer downloaded successfully"
                } else {
                  throw "Downloaded file is empty or invalid"
                }
              } catch {
                $retryCount++
                Write-Host "Download attempt $retryCount failed: $_"
                if ($retryCount -lt $maxRetries) {
                  Start-Sleep -Seconds 5
                }
              }
            }
            
            if (-not $downloadSuccess) {
              Write-Error "Failed to download NSIS installer after $maxRetries attempts"
              exit 1
            }
            
            # Устанавливаем NSIS в тихом режиме
            Write-Host "Installing NSIS..."
            $installProcess = Start-Process -FilePath $nsisInstaller -ArgumentList "/S" -Wait -PassThru -NoNewWindow
            
            if ($installProcess.ExitCode -ne 0) {
              Write-Warning "NSIS installer exited with code: $($installProcess.ExitCode)"
            }
            
            # Проверяем установку и добавляем NSIS в PATH
            $nsisPath = "C:\Program Files (x86)\NSIS"
            if (Test-Path "$nsisPath\makensis.exe") {
              $env:PATH = "$nsisPath;$env:PATH"
              Write-Host "NSIS installed successfully to: $nsisPath"
            } else {
              # Пробуем альтернативный путь
              $altPath = "C:\Program Files\NSIS"
              if (Test-Path "$altPath\makensis.exe") {
                $nsisPath = $altPath
                $env:PATH = "$nsisPath;$env:PATH"
                Write-Host "NSIS found at alternative path: $nsisPath"
              } else {
                Write-Error "NSIS installation failed - makensis.exe not found"
                exit 1
              }
            }
          }
          
          # Проверяем установку
          $makensis = Get-Command makensis.exe -ErrorAction SilentlyContinue
          if ($makensis) {
            Write-Host "NSIS installed successfully"
            & makensis.exe /VERSION
          } else {
            Write-Host "Adding NSIS to PATH and checking again..."
            $env:PATH = "C:\Program Files (x86)\NSIS;$env:PATH"
            $makensis = Get-Command makensis.exe -ErrorAction SilentlyContinue
            if ($makensis) {
              Write-Host "NSIS found after PATH update"
            } else {
              Write-Error "NSIS not found in PATH"
              exit 1
            }
          }

      - name: Create NSIS installer
        shell: pwsh
        run: |
          $version = "${{ github.ref_name }}"
          $workspace = "${{ github.workspace }}"
          $stagingDir = "$workspace\staging"
          $installerScript = "$workspace\installer.nsi"
          
          Write-Host "Creating installer with version: $version"
          Write-Host "Staging directory: $stagingDir"
          Write-Host "Workspace: $workspace"
          
          # Убеждаемся что NSIS в PATH
          $nsisPath = "C:\Program Files (x86)\NSIS"
          if (Test-Path $nsisPath) {
            $env:PATH = "$nsisPath;$env:PATH"
            Write-Host "Added NSIS to PATH: $nsisPath"
          }
          
          # Используем makensis из PATH или напрямую
          $makensisPath = "$nsisPath\makensis.exe"
          if (Test-Path $makensisPath) {
            Write-Host "Using makensis from: $makensisPath"
            & $makensisPath /DPRODUCT_VERSION="$version" /DSTAGING_DIR="$stagingDir" "$installerScript"
          } else {
            # Пробуем найти в PATH
            $makensis = Get-Command makensis.exe -ErrorAction SilentlyContinue
            if ($makensis) {
              Write-Host "Using makensis from PATH: $($makensis.Path)"
              & makensis.exe /DPRODUCT_VERSION="$version" /DSTAGING_DIR="$stagingDir" "$installerScript"
            } else {
              Write-Error "makensis.exe not found. NSIS may not be installed correctly."
              Write-Host "Checking common NSIS locations..."
              $commonPaths = @(
                "C:\Program Files (x86)\NSIS\makensis.exe",
                "C:\Program Files\NSIS\makensis.exe",
                "$env:ProgramFiles\NSIS\makensis.exe",
                "$env:ProgramFiles(x86)\NSIS\makensis.exe"
              )
              foreach ($path in $commonPaths) {
                if (Test-Path $path) {
                  Write-Host "Found makensis at: $path"
                  & $path /DPRODUCT_VERSION="$version" /DSTAGING_DIR="$stagingDir" "$installerScript"
                  break
                }
              }
              if ($LASTEXITCODE -ne 0) {
                exit 1
              }
            }
          }
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "NSIS compilation failed"
            exit 1
          }
          
          # Проверяем что файл создан
          $installerFile = "$workspace\pimino-$version-setup.exe"
          if (Test-Path $installerFile) {
            Write-Host "Installer created: $installerFile"
            Get-Item $installerFile | Select-Object Name, Length
          } else {
            Write-Error "Installer file not found: $installerFile"
            exit 1
          }

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-release
          path: |
            pimino-${{ github.ref_name }}-windows-x64.zip
            pimino-${{ github.ref_name }}-src.zip
            pimino-${{ github.ref_name }}-setup.exe

  release:
    name: Create Release
    needs: [build-linux, build-windows]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Download Linux artifacts
        uses: actions/download-artifact@v4
        with:
          name: linux-release
          path: artifacts/linux

      - name: Download Windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: windows-release
          path: artifacts/windows

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            artifacts/linux/*
            artifacts/windows/*
          draft: false
          prerelease: false
          generate_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

